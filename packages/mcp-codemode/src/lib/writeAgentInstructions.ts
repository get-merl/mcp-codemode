import fs from "node:fs/promises";
import path from "node:path";
import { fileExists } from "@merl-ai/mcp-codemode-runtime";

const HEADER_MARKER = "<!-- Auto-generated by mcp-codemode - DO NOT EDIT DIRECTLY -->";

export interface LlmTarget {
  id: string;
  path: string;
  label: string;
  hint: string;
}

export const LLM_TARGETS: LlmTarget[] = [
  { id: "agents", path: "AGENTS.md", label: "AGENTS.md", hint: "AGENTS.md" },
  { id: "claude", path: "CLAUDE.md", label: "Claude Code", hint: "CLAUDE.md" },
  { id: "cursor", path: ".cursorrules", label: "Cursor", hint: ".cursorrules" },
  { id: "windsurf", path: ".windsurfrules", label: "Windsurf / Codeium", hint: ".windsurfrules" },
  { id: "cline", path: ".clinerules", label: "Cline", hint: ".clinerules" },
  { id: "copilot", path: ".github/copilot-instructions.md", label: "GitHub Copilot", hint: ".github/copilot-instructions.md" },
];

/**
 * Generate LLM instruction files for selected targets.
 * If a target file exists without the auto-generated header, appends to it.
 * If a target file was previously auto-generated, replaces it.
 */
export async function syncLlmInstructions(
  projectRoot: string,
  toolboxDir: string,
  targetIds: string[]
): Promise<{ synced: string[]; appended: string[] }> {
  const relativeToolboxDir = path.relative(projectRoot, toolboxDir);
  const normalizedToolboxDir =
    relativeToolboxDir.startsWith("..") || path.isAbsolute(relativeToolboxDir)
      ? toolboxDir
      : relativeToolboxDir;

  const instructions = generateInstructions(normalizedToolboxDir);
  const synced: string[] = [];
  const appended: string[] = [];

  for (const targetId of targetIds) {
    const target = LLM_TARGETS.find(t => t.id === targetId);
    if (!target) continue;

    const targetPath = path.join(projectRoot, target.path);
    const targetDir = path.dirname(targetPath);

    // Ensure directory exists
    await fs.mkdir(targetDir, { recursive: true });

    let finalContent: string;

    if (await fileExists(targetPath)) {
      const existingContent = await fs.readFile(targetPath, "utf-8");
      const markerIndex = existingContent.indexOf(HEADER_MARKER);

      if (markerIndex !== -1) {
        // File has auto-generated section, preserve content before marker and replace the rest
        const manualContent = existingContent.slice(0, markerIndex).trimEnd();
        if (manualContent.length > 0) {
          finalContent = `${manualContent}\n\n${generateFileContent(instructions)}`;
        } else {
          finalContent = generateFileContent(instructions);
        }
      } else {
        // File has manual content only, append our content after existing
        finalContent = `${existingContent.trimEnd()}\n\n${generateFileContent(instructions)}`;
        appended.push(target.path);
      }
    } else {
      // File doesn't exist, create new
      finalContent = generateFileContent(instructions);
    }

    await fs.writeFile(targetPath, finalContent, "utf-8");
    synced.push(target.path);
  }

  return { synced, appended };
}

/**
 * Check which LLM target files already exist in the project.
 */
export async function getExistingLlmTargets(projectRoot: string): Promise<string[]> {
  const existing: string[] = [];
  for (const target of LLM_TARGETS) {
    const targetPath = path.join(projectRoot, target.path);
    if (await fileExists(targetPath)) {
      existing.push(target.id);
    }
  }
  return existing;
}

function generateFileContent(instructions: string): string {
  return `${HEADER_MARKER}\n\n${instructions}`;
}

function generateInstructions(toolboxDir: string): string {
  return `## MCP Codemode

Type-safe wrappers for MCP server tools.

### Discover Tools

- \`${toolboxDir}/catalog.json\` — list of all servers and tools with descriptions
- \`${toolboxDir}/servers/{server}/tools/{tool}.ts\` — tool implementations

### Execute Tools

**Single tool call** → run directly, no script needed:

\`\`\`bash
echo '{}' | npx tsx ./${toolboxDir}/servers/supabase/tools/get_project_url.ts
echo '{"schemas": ["public"]}' | npx tsx ./${toolboxDir}/servers/supabase/tools/list_tables.ts
\`\`\`

Output: JSON to stdout.

**Multi-tool workflow** → create script in \`${toolboxDir}/scripts/\`:

\`\`\`typescript
// ${toolboxDir}/scripts/my-workflow.ts
import { listTables, executeSql } from "../servers/supabase/index.js";

async function main() {
  const tables = await listTables({ schemas: ["public"] });
  for (const table of tables.tables) {
    const count = await executeSql({ sql: \\\`SELECT COUNT(*) FROM \\\${table.name}\\\` });
    console.log(\\\`\\\${table.name}: \\\${count.rows[0].count} rows\\\`);
  }
}

main().catch(console.error);
\`\`\`

Run: \`npx tsx ${toolboxDir}/scripts/my-workflow.ts\`

### Decision Tree

| Scenario                      | Action                                                                    |
| ----------------------------- | ------------------------------------------------------------------------- |
| Single tool, simple input     | \`echo '{...}' \\| npx tsx ./${toolboxDir}/servers/{server}/tools/{tool}.ts\` |
| Multiple tools, chained logic | Create script in \`${toolboxDir}/scripts/\`                                   |
| Reusable workflow             | Create script in \`${toolboxDir}/scripts/\`                                   |`;
}
